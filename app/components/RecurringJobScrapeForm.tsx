"use client";

import { useState, useEffect } from "react";
import { useMutation, useQuery } from "convex/react";
import { api } from "../../convex/_generated/api";
import { Id } from "../../convex/_generated/dataModel";
import EmailSettingsModal from "./EmailSettingsModal";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { useToast } from "@/hooks/use-toast";
import {
  buildLinkedInJobSearchUrl,
  DEFAULT_JOB_SEARCH_DISTANCE_KM,
  DEFAULT_JOB_SEARCH_TIME_RANGE,
  parseLinkedInJobSearchUrl,
} from "@/lib/linkedin";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";

interface EmailSettings {
  enabled: boolean;
  timing: "auto" | "manual";
  delayMinutes: number;
  manualTime?: {
    hour: number;
    minute: number;
  };
}

interface RecurringJobScrapeFormProps {
  existingData?: {
    _id: Id<"recurringJobScrapes">;
    name: string;
    linkedinUrl: string;
    location?: string;
    frequency: "daily" | "weekly" | "monthly";
    dayOfWeek?: number;
    dayOfMonth?: number;
    hour: number;
    minute: number;
    enabled: boolean;
    emailSettings?: EmailSettings;
  };
  onSuccess?: () => void;
  onCancel?: () => void;
  onDelete?: (id: Id<"recurringJobScrapes">) => void;
}

export default function RecurringJobScrapeForm({
  existingData,
  onSuccess,
  onCancel,
  onDelete,
}: RecurringJobScrapeFormProps) {
  const [name, setName] = useState(existingData?.name || "");
  const [linkedinUrl, setLinkedinUrl] = useState(existingData?.linkedinUrl || "");
  const [location, setLocation] = useState(() => {
    if (existingData?.location) {
      return existingData.location;
    }
    if (existingData?.linkedinUrl) {
      return parseLinkedInJobSearchUrl(existingData.linkedinUrl)?.location || "";
    }
    return "";
  });
  const [frequency, setFrequency] = useState<"daily" | "weekly" | "monthly">(
    existingData?.frequency || "weekly"
  );
  const [dayOfWeek, setDayOfWeek] = useState(existingData?.dayOfWeek || 0);
  const [dayOfMonth, setDayOfMonth] = useState(existingData?.dayOfMonth || 1);
  const [hour, setHour] = useState(existingData?.hour || 9);
  const [minute, setMinute] = useState(existingData?.minute || 0);
  const [selectedPastScrape, setSelectedPastScrape] = useState<string>("");
  const [urlManuallyEdited, setUrlManuallyEdited] = useState(!!existingData);
  const [emailSettings, setEmailSettings] = useState<EmailSettings>(() => {
    // Handle legacy data migration
    if (existingData?.emailSettings) {
      return {
        ...{
          enabled: true,
          timing: "auto" as const,
          delayMinutes: 5,
          manualTime: { hour: 9, minute: 0 },
        },
        ...existingData.emailSettings,
      };
    }

    // Convert from legacy digestEnabled format
    if (existingData && 'digestEnabled' in existingData) {
      const legacyData = existingData as typeof existingData & { digestEnabled?: boolean };
      return {
        enabled: legacyData.digestEnabled || false,
        timing: "auto",
        delayMinutes: 5,
        manualTime: { hour: 9, minute: 0 },
      };
    }

    // Default for new records
    return {
      enabled: true,
      timing: "auto",
      delayMinutes: 5,
      manualTime: { hour: 9, minute: 0 },
    };
  });
  const [showEmailModal, setShowEmailModal] = useState(false);

  const createRecurringJobScrape = useMutation(api.recurringJobScrapes.createRecurringJobScrape);
  const updateRecurringJobScrape = useMutation(api.recurringJobScrapes.updateRecurringJobScrape);
  const pastJobScrapes = useQuery(api.jobScraping.listJobScrapes);
  const { toast } = useToast();

  const [isSubmitting, setIsSubmitting] = useState(false);

  // Auto-generate LinkedIn URL from scrape name
  useEffect(() => {
    if (urlManuallyEdited) {
      return;
    }

    const trimmedName = name.trim();
    const trimmedLocation = location.trim();

    if (!trimmedName || !trimmedLocation) {
      return;
    }

    const autoGeneratedUrl = buildLinkedInJobSearchUrl({
      keywords: trimmedName,
      location: trimmedLocation,
      distance: DEFAULT_JOB_SEARCH_DISTANCE_KM,
      timeRange: DEFAULT_JOB_SEARCH_TIME_RANGE,
    });
    setLinkedinUrl(autoGeneratedUrl);
  }, [name, location, urlManuallyEdited]);

  const handleNameChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setName(e.target.value);
    // Reset manual edit flag when user changes the name (unless editing existing data)
    if (!existingData) {
      setUrlManuallyEdited(false);
    }
  };

  const handleLocationChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setLocation(e.target.value);
    if (!existingData) {
      setUrlManuallyEdited(false);
    }
  };

  const handleUrlChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setLinkedinUrl(e.target.value);
    // Mark URL as manually edited when user changes it directly
    setUrlManuallyEdited(true);
  };

  const extractSearchTerms = (linkedinUrl: string) => {
    const parsed = parseLinkedInJobSearchUrl(linkedinUrl);
    if (!parsed) {
      return "Custom search";
    }

    const keywords = parsed.keywords || "Custom search";
    return parsed.location ? `${keywords} in ${parsed.location}` : keywords;
  };

  const handlePastScrapeSelect = (scrapeId: string) => {
    if (scrapeId === "") return;

    const scrape = pastJobScrapes?.find((s) => s._id === scrapeId);
    if (scrape) {
      setName(scrape.name);

      const parsed = scrape.linkedinUrl ? parseLinkedInJobSearchUrl(scrape.linkedinUrl) : null;
      const parsedLocation = parsed?.location || "";
      setLocation(parsedLocation);

      const keywordsForUrl = parsed?.keywords || scrape.name;
      if (keywordsForUrl && parsedLocation) {
        const rebuiltUrl = buildLinkedInJobSearchUrl({
          keywords: keywordsForUrl,
          location: parsedLocation,
          distance: DEFAULT_JOB_SEARCH_DISTANCE_KM,
          timeRange: DEFAULT_JOB_SEARCH_TIME_RANGE,
        });
        setLinkedinUrl(rebuiltUrl);
        setUrlManuallyEdited(false);
      } else {
        setLinkedinUrl(scrape.linkedinUrl || "");
        setUrlManuallyEdited(true); // Don't auto-generate when information is incomplete
      }
    }
  };

  const handlePastScrapeChange = (value: string) => {
    if (value === "__none__") {
      setSelectedPastScrape("");
      return;
    }
    setSelectedPastScrape(value);
    handlePastScrapeSelect(value);
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    if (!name.trim()) {
      toast({
        variant: "destructive",
        title: "Validation error",
        description: "Please enter a name for the recurring scrape",
      });
      return;
    }

    if (!location.trim()) {
      toast({
        variant: "destructive",
        title: "Validation error",
        description: "Please enter a location for the recurring scrape",
      });
      return;
    }

    if (!linkedinUrl.includes("linkedin.com/jobs/search")) {
      toast({
        variant: "destructive",
        title: "Validation error",
        description: "Please enter a valid LinkedIn job search URL",
      });
      return;
    }

    setIsSubmitting(true);

    try {
      const args = {
        name: name.trim(),
        location: location.trim(),
        linkedinUrl: linkedinUrl.trim(),
        frequency,
        dayOfWeek: frequency === "weekly" ? dayOfWeek : undefined,
        dayOfMonth: frequency === "monthly" ? dayOfMonth : undefined,
        hour,
        minute,
        emailSettings,
      };

      if (existingData) {
        await updateRecurringJobScrape({
          id: existingData._id,
          ...args,
        });
      } else {
        await createRecurringJobScrape(args);
      }

      toast({
        title: existingData ? "Search updated" : "Search created",
        description: existingData
          ? "Recurring job search updated successfully!"
          : "Recurring job search created successfully!",
      });

      if (onSuccess) {
        onSuccess();
      }

      // Reset form if creating new
      if (!existingData) {
        setName("");
        setLocation("");
        setLinkedinUrl("");
        setFrequency("weekly");
        setDayOfWeek(0);
        setDayOfMonth(1);
        setHour(9);
        setMinute(0);
        setSelectedPastScrape("");
        setUrlManuallyEdited(false);
        setEmailSettings({
          enabled: true,
          timing: "auto",
          delayMinutes: 5,
          manualTime: { hour: 9, minute: 0 },
        });
      }
    } catch (error) {
      toast({
        variant: "destructive",
        title: "Error",
        description: `Failed to save recurring search: ${error}`,
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  const dayOfWeekOptions = [
    { value: 0, label: "Sunday" },
    { value: 1, label: "Monday" },
    { value: 2, label: "Tuesday" },
    { value: 3, label: "Wednesday" },
    { value: 4, label: "Thursday" },
    { value: 5, label: "Friday" },
    { value: 6, label: "Saturday" },
  ];

  return (
    <div className="mx-4 w-full max-w-md rounded-xl bg-card p-6 text-card-foreground shadow-lg">
      <div className="flex justify-between items-start mb-6">
        <h2 className="text-xl font-semibold">
          {existingData ? "Edit" : "Create"} Scheduled Search
        </h2>
        {existingData && onDelete && (
          <Button
            type="button"
            size="sm"
            variant="destructive"
            onClick={() => onDelete(existingData._id)}
          >
            Delete
          </Button>
        )}
      </div>

      <form onSubmit={handleSubmit} className="mt-6 space-y-5">
        {!existingData && pastJobScrapes && pastJobScrapes.length > 0 && (
          <div className="space-y-2">
            <Label>Use Settings from Past Search (Optional)</Label>
            <Select
              value={selectedPastScrape || "__none__"}
              onValueChange={handlePastScrapeChange}
            >
              <SelectTrigger>
                <SelectValue placeholder="Select a past search" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="__none__">Don&apos;t reuse settings</SelectItem>
                {pastJobScrapes.map((scrape) => (
                  <SelectItem key={scrape._id} value={scrape._id}>
                    {scrape.name} — {scrape.linkedinUrl ? extractSearchTerms(scrape.linkedinUrl) : "Custom search"}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
            <p className="text-xs text-muted-foreground">
              Populates the name and LinkedIn URL fields.
            </p>
          </div>
        )}

        <div className="space-y-2">
          <Label htmlFor="recurring-name">Search Name</Label>
          <Input
            id="recurring-name"
            value={name}
            onChange={handleNameChange}
            placeholder="e.g., Weekly Software Engineer Jobs"
            required
          />
          <p className="text-xs text-muted-foreground">
            LinkedIn URL will auto-generate based on your search name
          </p>
        </div>

        <div className="space-y-2">
          <Label htmlFor="recurring-location">Location</Label>
          <Input
            id="recurring-location"
            value={location}
            onChange={handleLocationChange}
            placeholder="Amsterdam, North Holland, Netherlands"
            required
          />
          <p className="text-xs text-muted-foreground">
            City, region, country format works best for LinkedIn job searches.
          </p>
        </div>

        <div className="space-y-2">
          <Label htmlFor="recurring-linkedin">LinkedIn Job Search URL</Label>
          <Input
            id="recurring-linkedin"
            type="url"
            value={linkedinUrl}
            onChange={handleUrlChange}
            placeholder="https://www.linkedin.com/jobs/search?keywords=..."
            required
          />
          <p className="text-xs text-muted-foreground">
            Auto-populated. You can edit this URL manually if needed.
          </p>
          <p className="text-xs text-muted-foreground">
            Apify runs with the workspace API key configured via environment variables.
          </p>
        </div>

        <div className="space-y-2">
          <Label>Frequency</Label>
          <Select
            value={frequency}
            onValueChange={(value) => setFrequency(value as "daily" | "weekly" | "monthly")}
          >
            <SelectTrigger>
              <SelectValue placeholder="Select frequency" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="daily">Daily</SelectItem>
              <SelectItem value="weekly">Weekly</SelectItem>
              <SelectItem value="monthly">Monthly</SelectItem>
            </SelectContent>
          </Select>
        </div>

        {frequency === "weekly" && (
          <div className="space-y-2">
            <Label>Day of Week</Label>
            <Select
              value={dayOfWeek.toString()}
              onValueChange={(value) => setDayOfWeek(Number(value))}
            >
              <SelectTrigger>
                <SelectValue placeholder="Select a day" />
              </SelectTrigger>
              <SelectContent>
                {dayOfWeekOptions.map((option) => (
                  <SelectItem key={option.value} value={option.value.toString()}>
                    {option.label}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
        )}

        {frequency === "monthly" && (
          <div className="space-y-2">
            <Label>Day of Month</Label>
            <Select
              value={dayOfMonth.toString()}
              onValueChange={(value) => setDayOfMonth(Number(value))}
            >
              <SelectTrigger>
                <SelectValue placeholder="Select a day" />
              </SelectTrigger>
              <SelectContent className="max-h-64">
                {Array.from({ length: 31 }, (_, i) => i + 1).map((day) => (
                  <SelectItem key={day} value={day.toString()}>
                    {day}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
        )}

        <div className="grid gap-4 md:grid-cols-2">
          <div className="space-y-2">
            <Label>Hour (24h format)</Label>
            <Select
              value={hour.toString()}
              onValueChange={(value) => setHour(Number(value))}
            >
              <SelectTrigger>
                <SelectValue placeholder="hh" />
              </SelectTrigger>
              <SelectContent className="max-h-64">
                {Array.from({ length: 24 }, (_, i) => i).map((h) => (
                  <SelectItem key={h} value={h.toString()}>
                    {h.toString().padStart(2, "0")}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>

          <div className="space-y-2">
            <Label>Minute</Label>
            <Select
              value={minute.toString()}
              onValueChange={(value) => setMinute(Number(value))}
            >
              <SelectTrigger>
                <SelectValue placeholder="mm" />
              </SelectTrigger>
              <SelectContent className="max-h-64">
                {Array.from({ length: 60 }, (_, i) => i).map((m) => (
                  <SelectItem key={m} value={m.toString()}>
                    {m.toString().padStart(2, "0")}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
        </div>

        <div className="space-y-2">
          <Label>Email Notifications</Label>
          <Button
            type="button"
            variant="outline"
            onClick={() => setShowEmailModal(true)}
            className="w-full justify-between"
          >
            <span>
              {emailSettings.enabled
                ? emailSettings.timing === "auto"
                  ? `Auto (${emailSettings.delayMinutes} min delay)`
                  : `Manual (${emailSettings.manualTime?.hour?.toString().padStart(2, "0")}:${emailSettings.manualTime?.minute?.toString().padStart(2, "0")})`
                : "Disabled"}
            </span>
            <span className="text-muted-foreground">⚙️</span>
          </Button>
          <p className="text-xs text-muted-foreground">
            Configure when to send recap emails for this schedule.
          </p>
        </div>

        <div className="flex gap-2 pt-2">
          <Button type="submit" className="flex-1 bg-primary text-primary-foreground border-primary hover:bg-primary/90 hover:text-primary-foreground shadow-none" disabled={isSubmitting}>
            {isSubmitting
              ? existingData
                ? "Updating..."
                : "Creating..."
              : existingData
                ? "Update"
                : "Create"}
          </Button>
          {onCancel && (
            <Button
              type="button"
              variant="outline"
              onClick={onCancel}
              className="flex-1"
            >
              Cancel
            </Button>
          )}
        </div>
      </form>

      <EmailSettingsModal
        isOpen={showEmailModal}
        onClose={() => setShowEmailModal(false)}
        onSave={setEmailSettings}
        initialSettings={emailSettings}
      />
    </div>
  );
}
